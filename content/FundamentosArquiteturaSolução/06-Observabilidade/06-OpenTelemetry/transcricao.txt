Bom, pessoal, por último, mas não menos importante, sobre a observabilidade eu quero falar de um projeto que é muito promissor.  Já dá para usar diversas partes dele em produção, em algumas linguagens de programação, e que, na minha opinião, é o futuro da observabilidade. Esse projeto é chamado de OTel ou Open Telemetry. Ele é um projeto muito sério, também mantido pela CNCF (Cloud Native Computing Foundation). A ideia do Open Telemetry é a seguinte, vamos falar sobre isso, é um CNCS project, que é baseado no Open Tracing e no Open Census. Antigamente, existia um projeto chamado Open Tracing que gerava um padrão para essa parte de rastreamento. Porque todos os vendors, todas as empresas, todas as soluções que querem ter rastreamento implementam essa especificação, assim, fica fácil fazer o switch, a mesma coisa acontece com Open Census. E o Open Telemetry é a ideia dessa junção.

O Open Telemetry é baseado em especificações. Eu acho que uma das coisas mais importantes quando você vai falar sobre a observabilidade é você ter diversas ferramentas e diversos players. E esses players têm agentes que mandam informações do seu sistema para eles. Se essas informações seguirem a mesma especificação, as coisas ficam muito mais padronizadas e fica muito mais fácil, inclusive, você mudar de um player para o outro. Isso acaba sendo vantagem para todo mundo. Um outro ponto importante é, específico também protocolos, que eles criam protocolos específicos para a parte de telemetria. E também, além disso, eles geram SDKs, ou seja, kits de desenvolvimento para diversas linguagens. Então, imagina que eu quero utilizar o Open Telemetry para mandar as informações de tracing que eu estou trabalhando. Ao invés de eu ter que olhar a especificação, criar minha biblioteca em Go, para a linguagem Go, por exemplo, eu pego a biblioteca pronta que a Open Telemetry fez, eu importo e já saio utilizando. Fazemos a mesma coisa com as principais linguagens como Java, JavaScript, Python, C, C++, Ruby e assim por diante. Então, você tem esses SDKs.

 Uma outra coisa interessante também são ferramentas de integração.  Às vezes, você não quer ficar customizando a sua aplicação para que a sua aplicação fique gerando esses dados para mandar para o seu vendedor. Esses SDKs e mais algumas ferramentas ajudam a gerar esses dados de telemetria de forma automática. Isso a gente chama de instrumentação. Ou seja, vamos imaginar que eu tenho um software em Java. Na hora de eu subir o Java, menos jar e etc. eu passo um parâmetro falando que eu quero que ele passe para a instrumentação do Open Telemetry. Então, ele já fica ali e esse sistema de instrumentação, em tempo de execução, fica escutando a sua aplicação, pegando todos os dados dela para enviar. Agora o grande ponto é enviar para onde? E é por isso que a gente fala de integração. As ferramentas, quando você trabalha com esses SDKs do Open Telemetry,  tem duas opções. Uma opção é mandar os dados diretamente para o back-end. O back-end que eu digo é um vendor, tipo Elastic Stack, New Relic e Datadog. Outra opção é mandar os dados para um coletor. O coletor é um cara intermediário que recebe essa informação, trata essa informação e depois manda para o back-end. A gente vai falar sobre isso agora. Olha só que interessante, está vendo ali que você tem uma aplicação, a aplicação do lado... deixa eu pegar meu mouse para ficar melhor de eu ver. Essa minha aplicação está usando uma biblioteca do Open Telemetry, uma SDK. Então, tudo o que está acontecendo com essa minha aplicação, os dados são enviados para um coletor. Esse coletor é um agente, ou seja, ele pega essas informações e joga para um back-end. O que é um back-end? Um Dynatrace, um Datadog, um Elastic Stack etc. Portanto, esse coletor funciona como agente e manda para esse back-end. Essa é uma opção. 

Outra opção que você tem também é a seguinte, eu tenho essa outra aplicação que utiliza a library do Open Telemetry e depois ela manda essa informação para um coletor, para um agente, e esse coletor manda a informação para um outro coletor que é um serviço. Então, aqui é um agente e aqui é um serviço, um sistema de coletor. Imagina que um outro servidor pode estar em uma outra instância rodando um outro pod do Kubernetes. Esse coletor pega esses dados e manda para o back-end. Também tem a opção que não está aqui, eu posso pegar a minha aplicação e jogar direto para o meu serviço de coletor. Também há essa opção, apesar de ela não estar nesse desenho para vocês.

 Eu não sei se vocês já perceberam uma coisa, olha só que interessante. Você conseguiu perceber que essa aplicação está dentro de um host, ela está dentro de um servidor, e junto dessa aplicação a gente tem esse coletor? Esse coletor aqui está dentro do mesmo host dessa aplicação, não está? E ele está se comunicando com essa aplicação, concorda? Esse padrão que você está vendo é chamado de sidecar. A gente falou sobre sidecar na parte de design patterns. Olha só que interessante. Então, o que você está vendo é um sidecar. Ou seja, o coletor do Open Telemetry é considerado um sidecar, isto é, ele fica do lado da sua aplicação se comunicando. Eu poderia ter um coletor de métricas, que nem a gente está fazendo agora. Eu poderia ter um coletor, quer dizer, um outro sidecar de alguma outra coisa. Mas olha só que interessante, uma outra coisa importante sobre esses coletores do Open Telemetry é o seguinte, ele não só pega o dado e joga para o coletor e o coletor manda para o Elastic. Esse coletor funciona como um serviço de tratamento dessa informação. Então, eu posso pegar essa informação, transformar essa informação no meio do caminho, dentro desse serviço, e o serviço pegar essa informação dentro de um padrão para jogar para o back-end. Assim, você consegue criar uma espécie de uma transformação aqui dentro para você conseguir fazer isso. Uma coisa, uma grande vantagem que você tem de utilizar esses coletores, ou mandar os dados com essas bibliotecas, é que como os back-ends implementam o padrão da especificação do Open Telemetry. Vamos imaginar que esse back-end 1 é o Elastic Stack e vamos imaginar que esse outro é o WS CloudWatch, e você uma hora está mandando os dados para o Elastic Stack e você fala: “não, eu fiz um acordo com a WS, eu quero pegar esse cara e jogar no Elastic Stack, no CloudWatch”. Eu mudo a configuração do meu coletor, o endpoint, e ao invés dele mandar para o Elastic, ele manda para cá e eu não precisei mudar o código da minha aplicação. Então é isso que é o ponto importante, eu não tenho que fazer uma implementação para cada vendedor, para cada back-end, ou seja, eu simplesmente mudo os endpoints. Obviamente, mudo uma configuração no meu coletor e essa informação já vai. Isso gera um poder muito grande na mão dos desenvolvedores e também facilita muito essa integração entre vendors. Lembrando uma coisa interessante, inclusive, lembra que eu falei para vocês que tem algumas empresas que trabalham com logs jogando no Elastic e o tracing joga no Datadog? Dá para fazer isso por aqui. Eu posso falar que esse meu coletor vai pegar todas as métricas e jogar no back-end 1, está vendo? Métricas e tracing. E eu quero pegar só métricas também e jogar no back-end 2, então, eu jogo aqui. Eu consigo fazer com que o meu coletor se comunique com diversos back-ends e mande as informações que eu quiser para cada um dos back-ends de uma vez só. Porém, o mais interessante é que a sua aplicação não precisa necessariamente ficar se comunicando com cada back-end. Você manda a sua aplicação se comunicar só com esse sidecar. Mas você sim, tem a opção de fazer a sua aplicação mandar a informação direto para o back-end. Dá para fazer isso também, não necessariamente você precisa ficar usando o coletor todas as vezes, mas é o mais recomendável. Porque o colector usa o tempo dele para mandar essas informações, ao invés de você ficar fazendo chamadas síncronas direto para um back-end.

 Então, essa é a ideia desse projeto do Open Telemetry. É importante você saber que esse projeto existe. No momento que eu estou gravando, já existem linguagens de programação que  tem os SDKs para métricas e para tracing. Existem também linguagens que tem só tracing e as métricas não estão implementadas. Existem linguagens que têm métricas e tracing que estão em alfa e logs estão em alfa, ou logs não estão implementados. Então, o que eu recomendo? Sempre que você quiser olhar o Open Telemetry, entra no site do Open Telemetry, acredito que seja “opentelemetry.io”. Nesse site, tem as linguagens. Você clica na linguagem e ele vai mostrar para vocês o status de implementação dos SDKs, tanto para tracing, quanto para logs e métricas. E, assim, ele mostra se já está estável e você sabe quando e qual você pode utilizar. Somente uma dica para vocês. Portanto, era isso que eu queria falar para vocês, principalmente sobre essa parte de observabilidade. Então, vamos seguindo!