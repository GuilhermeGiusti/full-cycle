Agora, meu povo, nós vamos falar sobre Distributed Locking, Lock distribuído. Para que serve? O lance é o seguinte: toda vez que estamos trabalhando com um sistema muito crítico, muitas vezes o nosso maior problema, o nosso maior desafio está na concorrência. O que isso significa? Vamos imaginar que nós temos um e-commerce e esse e-commerce tem um único produto para venda. Só tem um produto em estoque, e estamos no meio de uma Black Friday. Já pensou se o cliente A e o cliente B compram esse produto no exato momento, e para eles fazerem a compra, o que eles precisam fazer? Consultar o estoque. Mas, na hora que eles consultam o estoque simultaneamente, consta que tem um produto, mas na hora que eles vão fazer o restante da compra, você vai perceber que eles venderam um único produto para duas pessoas. Por quê? Porque isso foi um problema clássico de concorrência. Como você pode evitar esses tipos de concorrência? Muita gente faz o seguinte: Opa, eu vou criar um cachezinho local aqui no meu sistema. E que acontece? Na hora que os caras acessarem juntos, eu consigo saber se aquele cara já está comprado ou eu posso dar um lockezinho ali e não tem problema esse problema de concorrência. Até então funciona, mas, o grande problema é que hoje em dia as nossas aplicações escalam e eu não tenho apenas um sistema, eu tenho dez sistemas iguais rodando em servidores diferentes. Dessa forma, não adianta apenas uma máquina aqui, de uma forma geral, localmente, tentar resolver esse problema, por que eu tenho as outras máquinas rodando, entende?

 

Como que eu consigo resolver esse problema de concorrência através de lock distribuído? O lock distribuído vai ser uma forma de bloquear um registro, bloquear uma operação caso duas pessoas, dois sistemas, duas requisições tentem alterar ao mesmo tempo. Então, você vai bloquear essa requisição, o outro não vai conseguir alterar e depois que você executou a sua operação, você desbloqueia. Legal? Agora, a grande sacada disso aqui ser distribuído é pelo fato de conseguir fazer isso, independente da quantidade de máquinas que estejam rodando. Qual é a grande vantagem de conseguir trabalhar com lock distribuído? Consistência nos dados. Uma das principais vantagens aqui é a consistência nos dados. Por quê? Porque no final do dia, você garante que não vai vender um único produto para duas pessoas. Uma outra coisa aqui é a parte de contenção de recursos. O que acontece, galera? Toda vez que você vai fazer uma operação desse tipo, você vai obrigar, por exemplo, um banco de dados a fazer o quê? Travar linhas de bancos de dados específicas, um monte de requisição fica acessando e vai fazendo com que gaste mais recurso o tempo todo. Porque não adianta, você vai fazer essa operação com várias máquinas ao mesmo tempo, vai gerar um modo de contenção, vai fritar o seu banco de dados, vai deixar a aplicação mais lenta e não vai resolver necessariamente o seu problema.

 

Um outro ponto importante também é que você evita dead locks. O que isso significa? Imagina o seguinte: eu tenho o cliente A e o cliente B. O cliente A tem que alterar o registro A e o cliente B quer alterar o registro B, porém, quando ele altera a opção A, ele tem que fazer um update na versão B. E, o outro, quando ele altera a versão B, ele quer alterar uma por consequência o registro da versão A. Mas, o que acontece? Se você dá um lock no A, no sistema um e dá um lock no B, no sistema dois, quando o A tentar alterar o B, ele não vai conseguir, porque o B está bloqueado pelo sistema dois, e quando o sistema dois tentar alterar o A, ele não consegue porque o sistema A está bloqueado. Então, ambos não vão poder fazer nada e a gente tem a situação da dead lock. Isso é uma coisa que acontece, ou seja, você precisa alterar um registro que o outro está bloqueado e o outro precisa alterar o registro que você bloqueou e daí ninguém consegue avançar e você tem uma dead lock.

 

E por último, você garante mais eficiência nos recursos, por que você vai ter um cara centralizador com todos os looks, e esse cara é feito e otimizado para resolver esse tipo de problema. Quem chega primeiro é o Lock, depois que o cara utilizou, você vai dar um unlock, é basicamente isso. Mas, isso de uma forma externa, você não vai fazer o lock para cada máquina, para cada instância que você está trabalhando. O seu sistema de lock distribuído vai ser uma máquina à parte, um servidor à parte, só vai gerenciar os locks ali para você. Quais servidores? Quais tecnologias eu posso utilizar para fazer os locks? Pode utilizar o Zookeeper, por exemplo, que é uma ferramenta excelente para gerenciamento de nodes, gerenciamento de locks, conseguir fazer consenso, porque os seus locks também podem ter diversos nodes e esses nodes tem que estar replicados, entendeu? O outro é o ETCD, que é o mesmo banco de dados que você tem no Kubernetes. O Redis, que é fantástico, e o Consul, por exemplo, da Rest Corp. Agora, o que é necessário entender é que todas essas tecnologias têm prós e contras. Vou dar um exemplo: o Zookeeper é uma ferramenta fantástica. Para vocês terem uma ideia, hoje, o Zookeeper é o cara que gerencia todos os nodes do Apache Kafka.

 

Porém, o que acontece hoje? O Zookeeper está atrás, por exemplo, de consistência. Por que quando você está com distributed Locking, esse seu servidor que você tem para lock não é apenas uma máquina, você tem que ter diversos nodes para ele aguentar a escala. Agora, como eu garanto que o lock que alguém acabou de dar já foi replicado em todos os outros nodes do Zookeeper? Então o  Zookeeper é muito rápido para garantir essa consistência e ele tem um protocolo, uma espécie de um protocolo próprio para conseguir fazer isso. Por outro lado, quando você quer garantir muita consistência, você perde o quê? Velocidade. Logo, o Zookeeper não é o cara que tem o maior throughput, ou seja, ele aguenta a maior quantidade de requisições. Agora, eu vou dar um exemplo do Redis. O Redis é o banco de dados que consegue gravar os dados físicos e também na memória, mas, de forma geral, nesses casos nós trabalhamos só na memória. Assim, você consegue gravar essas informações de uma forma muito rápida. O grande ponto é o seguinte: o Redis, quando ele está rodando de forma distribuída, o tempo de replicação dessas informações para os outros nodes pode demorar um pouco. E o que acontece? Quando demorar, se o node master que recebeu a informação caiu, pode ser que você pegue a informação desatualizada até ele fazer um outro consenso para subir um novo master ali. Entendeu? Portanto, temos que tomar muito cuidado com isso, apesar de poder rodar com o Redis de forma mais eficiente para correctness que a gente fala, ou seja, para garantir essa consistência. Mas, quando você roda ele com essa maior consistência, talvez rodar o Zookeeper seja melhor. Ele vai ter mais consistência ainda do que o Redis, porém, o Redis vai ser mais rápido do que o Zookeeper. Normalmente a galera usa mais Redis. Por quê? Por que você tem as a service na Amazon, tem as a service em tudo quanto é lugar. Já o Zookeeper, eu, pelo menos, nunca vi o Zookeeper as a Service, logo, em tese, você teria que gerenciar o cluster. Mas, de qualquer forma, são ótimas ferramentas e vão resolver esse seu problema para trabalhar com lock distribuído. “Wesley, queria dar uma olhada, por curiosidade de código, como é que funciona o lock and lock?” Olha só, eu peguei um exemplo bem simples, em TypeScript. Basicamente, você faz a conexão com o Zookeeper, depois você fala o que quer bloquear, eu vou falar: “Quero bloquear o produto um, o Product ID” e você vai fazer um lock. Quando eu dou um lock, eu estou falando para o Zookeeper bloquear isso para mim, e isso é chamado de Lock Zone, ou seja, zona de lock. 

 

Então, eu estou falando assim: “no barra Product id um, bloqueia isso para mim”, quando ele bloquear, quando algum outro usuário tentar acessar e falar que quer bloquear aquilo, ele já vai receber uma exception. Legal? Depois que você utilizou esse produto, fez as alterações, você dá um unlock e libera essa parada aqui. Uma coisa interessante nesse caso com o Zookeeper é o seguinte: você consegue trabalhar em formatos de namespaces, então eu posso colocar / product, / ID, / data, / isso e / aquilo. Você vai criando todo um namespace para criar a sua lock zone, e fica bem legal para você conseguir trabalhar com o Zookeeper. Se você vê, é uma implementação, de forma geral, bem simples, e no dia a dia, é simples mesmo, você pede para locar, se já estiver locado, você vai receber uma exception. Entende? Se não tiver locado, você vai locar, vai autorizar e vai ter que dar unlock. Aí a próxima pessoa que tentar acessar, vai chegar lá. Beleza? Essa é a ideia básica desse pattern, que é algo bem comum nós utilizarmos em grandes aplicações. O Lock Distribuído.