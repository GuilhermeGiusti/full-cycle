Bom pessoal, no vídeo anterior nós entendemos a ideia básica do cache, mas eu falei para vocês que o segredo do cache não está nesse formato de você utilizar, está em entender como que a gente pode trabalhar com invalidação. Como é que funciona isso aqui? Nós temos diversas estratégias de invalidação e são essas estratégias que eu queria mostrar aqui, para que você tenha uma linha de raciocínio na hora de pensar em qual é a melhor forma de invalidar o cache. Como eu já disse para vocês, os dados do cache podem mudar e eles podem ficar ultrapassados. Por quê? Porque a aplicação gerou alguma transação que refletiu naquele dado. E, se a gente for consultar o dado diretamente, nós vamos estar com o dado mais antigo. Então, a nossa ideia é, como que eu consigo manter o máximo possível na consistência dos meus dados. Legal? E, é para isso que nós temos as estratégias de invalidação. Como é que funciona essas estratégias de invalidação? Eu tenho uma estratégia que é chamada de Time-based Invalidation, e nós já vamos falar sobre ela. Eu vou explicar cada uma delas. Nós temos outra chamada de Least Recently Used ou (LRU). Nós temos a (MRU), que é Most Recently Used. Nós temos uma outra chamada de Least Frequently Used, (LFU). E temos também uma que é chamada de TTL-based Invalidation, TTL significa time to level, ou seja, o tempo de vida.

 

Existem mais duas outras estratégias que são importantes, mas não são tão comuns de ver a galera falar. A primeira é Write-through Invalidation e a outra é o Write-back Invalidation. Então, como vocês podem ver, pode parecer muito simples a utilização do cache, mas se não utilizar as estratégias corretas, você não vai conseguir tirar o melhor disso. Ou também, se você não entender a estratégia correta, você vai poder estar retornando dados inconsistentes para o seu usuário e você não quer isso. Então, vamos dar uma olhada e entender de uma forma geral como funciona cada uma dessas estratégias de invalidação. Vamos lá! Time-based Invalidation, deixa eu só voltar aqui, porque eu não criei um slide específico para isso, porque ela é a mais simples. Time-based Invalidation é o seguinte, você fala: “olha, daqui dez horas eu quero que esse cache desapareça”, ou seja, o cache vai ser limpo em um tempo específico, simples assim. Portanto, eu gravei algo e falo: “esse cache vai durar por 05h00”, depois disso pode remover do cache para a gente gravar um dado mais recente ali. Legal? Normalmente, isso é muito utilizado em sites que têm muitos acessos. Normalmente, são sites de acesso à informação, tipo um site de notícias, ou eventualmente, quando você normalmente tem uma noção de quando os dados devem ser atualizados por algum evento que acontece no sistema. Você sabe que, por exemplo, todo dia, na parte da noite você atualiza um relatório, então você consegue trabalhar mais ou menos nessa pegada. 

 

Agora, vamos falar sobre (LRU) Least Recently Used. Para que ele serve? Eu acho que a melhor forma para nós entendermos, é com algum exemplo um pouquinho mais simples aqui. O Least Recently Used significa que, o que foi utilizado de forma menos recente, ou seja, vamos imaginar o seguinte: todo o cache tem um limite de memória. Imagina que você tem uma máquina e tem 1gb para cache, mas quando esse cache encher, eu tenho que dar um jeito de jogar alguma coisa fora para eu entrar com um dado mais novo. E, é por conta disso que nós temos que ter essas estratégias para saber como vamos jogar esses dados fora. Logo, essa Least Recently Used é uma forma de você conseguir jogar fora os dados menos recentes. Como é que funciona? Vamos imaginar que eu tenho um registro que eu cacheei A, depois cacheei B e depois eu cacheei C. Mas, o que acontece agora? Eu tenho apenas três posições para guardar o meu cache. Eu não consigo guardar quatro registos porque eu vou ficar sem memória, dessa forma, vou ter que escolher uma estratégia para remover o A, B ou o C para eu conseguir colocar o meu D.

 

Então, como é que eu posso fazer usando LRU? Eu vou colocar o D, mas para colocar o D alguém vai ter que ir embora e nesse caso, quem vai embora é o A, porque ele foi o menos recente, ou seja, eu tô dando preferência aqui para os caras mais novos e o cara menos recente nós vamos jogar fora. Assim, essa é uma ideia super simples para você entender quando você utiliza essa estratégia. Vamos para outra estratégia que é (MRU), Most Recently Used. O que essa estratégia faz? Ela joga fora a versão mais recente, e você deve estar pensando: “Poxa, por que eu vou jogar fora a versão mais recente?” Por incrível que pareça, isso é mais comum do que você imagina. Vamos imaginar que eu tenho uma CDN uma Content Delivery Network. Imagina que todos os vídeos que você está assistindo agora, estão passando por uma CDN. Então, esse vídeo que você está assistindo agora é cacheado em uma CDN, para que todo mundo que acesse, acesse esse vídeo mais perto. Você concorda que esse vídeo é a versão mais atual porque ele foi cacheado? Agora, já que ela é a versão mais atual, o que eu quero fazer? Quero mudar essa versão porque eu alterei esse vídeo, eu fui subir e adicionei alguma coisa no vídeo. Logo, ele vai pegar essa versão mais atual e jogar fora para colocar a nova aí na frente. Portanto, a MRU serve para isso. Eu tinha a versão C, joguei fora essa versão para entrar, no final das contas, a versão C novamente. Porém, uma versão modificada aqui para a gente. Legal? A MRU é muito comum, e normalmente, você só tem uma versão daquele mesmo cara.

 

Agora, nós temos a (LFU) que é Least Frequently Used. O que essa versão faz? Ela joga fora, quando o cache tá cheio, o registro que tem menos acessos. Não interessa se ele foi guardado antes ou depois, é jogado o que tem menos acesso. Então, vamos imaginar que eu tenho um registro, os dados A foram acessados 7 vezes, aí eu tenho o B que foi 6, tenho o C-5 e tenho o D-10. Qual vai ser jogado fora na hora que o cache encher? o C. Porque ele é o cara que teve a menor frequência de acessos. E, nesse caso, esse cara vai embora.

 

Agora, vamos falar desse cara aqui, Write-through Invalidation. Para o que ele serve? O lance é o seguinte: existem sistemas que não tem tanta gravação, mas ele pode ter muita leitura. E, para conseguir produzir um cache e já dar a leitura com os dados mais recentes, rapidão ali para você. O que você pode fazer? Sempre quando há alteração no disco, por exemplo, se alterou os dados no seu banco de dados, o cache é atualizado um conjunto. Assim, além de guardar os dados diretamente no banco, por exemplo, eu salvei um registro de uma alteração de um texto, de uma notícia. Na hora que eu salvei essa alteração, automaticamente eu já salvei essa informação no cache também. Legal? Então, isso se chama Write-through Invalidation. Por quê? Porque a gente evita ao extremo com que a pessoa acesse o disco. Por quê? Porque na hora que eu altero no disco, já altero no cache e você já vai buscar sempre no cache e isso se chama Write-through Invalidation. Então, é o seguinte: essa estratégia funciona bem com sistemas que não possuem um alto índice de escrita, porque se tiver muita escrita, aí vai forçar muito a barra e você tem que persistir em dois lugares todas as vezes. 

 

E agora nós temos o outro, que é chamado de Write-back Invalidation. Esse cara aqui, honestamente, eu nunca vi alguém utilizar, mas é uma estratégia. O Write-back Invalidation é o seguinte: imagina que você está tendo muita escrita nos seus dados, ou o seu cache está atualizando recentemente. Então, ao invés de na hora em que você for fazer uma atualização você guardar no seu banco de dados, você guarda primeiro no seu cache, você dá prioridade no seu cache em relação ao seu banco de dados e quando esse cache, por algum motivo estiver para expirar, você salva nesse banco de dados, ou quando o cache foi gravado, um tempo depois você manda esse cara gravar no banco de dados. Logo, quando há alteração, o cache primeiramente é atualizado e depois o dado em disco é atualizado. Muitas vezes o dado em disco é atualizado quando o cache já está para expirar de alguma forma.

 

Galera, como vocês podem perceber, muito aqui do que nós queremos trazer nesse programa, é fundamento. Eu sei que tem gente que adora sujar a mão de código e nós vamos fazer isso durante todo o nosso curso. Porém, o fundamento é muito importante e eu acredito que no momento da carreira que você está, entender esses fundamentos é muito mais interessante do que saber dar um sete no Redis e dar um get no Redis. Entende? A diferença das pessoas que estão liderando grandes projetos e estão arquitetando grandes projetos, é que elas têm esses fundamentos e esses fundamentos vão fazer a diferença na hora que a coisa crítica acontecer. Beleza? É isso aí, vamos para o nosso próximo pattern.