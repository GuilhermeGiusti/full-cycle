A gente vai falar sobre confiabilidade. O que é confiabilidade? O pilar de confiabilidade abrange a capacidade de uma carga de trabalho, um workload, de executar sua função pretendida de forma correta e consistente quando é esperado. Isso inclui a capacidade de operar e testar a carga de trabalho durante todo o seu ciclo de vida. No final das contas, o que isso quer dizer? Aquilo que precisa estar no ar, tem que estar no ar funcionando, independente do tipo de evento que aquilo acontecer. Tive muita visita, a “parada” tem que funcionar. Tive que mudar de cloud provider, a “parada” tem que funcionar. Tive que fazer algumas mudanças nas operações e etc. A minha aplicação precisa “estar” confiável. Então, isso é uma das coisas mais complexas, porque se você pensar bem é o seguinte, toda vez que você vai falar em confiabilidade é: eu quero rodar minha aplicação e ela tem que estar funcionando. Agora, para fazer isso é complexo. Para que você consiga manter a operação de algo funcionando, que seja confiável e consistente, ela tem que ser desde nível de performance, desde nível de escalabilidade, até nível de segurança também. Desde quando a aplicação está sendo deployada, desde quando a aplicação está saindo do ar, você tem que ter esses níveis de confiabilidade ajustados. 

Quais são os principais, novamente, quais são os princípios da confiabilidade? Primeira coisa, recupere-se automaticamente de falhas. O que acontece? O que é muito comum? Um serviço falhou, a aplicação caiu e você vai precisar de uma pessoa para ir lá restaurar essa aplicação. Ou você vai precisar de uma pessoa para ir lá no Kubernetes remover e subir o pod novamente. Então, esses tipos de coisa não podem ser de forma manual. Existe um conceito extremamente importante que a gente chama de self-healing. O que é self-healing no final das contas? É você ter a capacidade de auto cura. Eu vou dar um exemplo muito claro para você. Vou imaginar que a gente está rodando a aplicação A e B. A aplicação A mandou tanta requisição que a aplicação B travou. Como eu consigo fazer a aplicação B voltar no ar automaticamente? Então, olha só que interessante, esse é um princípio de self-healing. Essa aplicação tem que voltar no ar desde que ela tenha as condições de self-healing para ela. Por exemplo, trabalhar com o Circuit Breaker. O que o Circuit Breaker vai fazer? Quando a aplicação está caindo, ela para de receber requisição, termina de processar o que precisava, volta ao ar da maneira como ela estava e depois começa a receber novamente aquelas requisições. 

Você sempre tem que pensar em estratégias para que, caso alguma coisa caia do ar, aquela aplicação possa voltar sem depender ao máximo de uma intervenção humana. Então, isso é um ponto importantíssimo para você. Outro ponto é o teste de procedimentos de recuperação. Essa é uma das coisas que consideramos ser um dos erros mais contundentes que podemos ter no dia a dia. Teste de procedimento de recuperação. Vamos derrubar esse serviço, o que acontece? Ele consegue se recuperar? Outra coisa, por exemplo, recuperação de dados. Aconteceu alguma coisa e morreu o seu banco de dados. Você vai ter que subir um banco de dados do zero e aplicar o backup dele. Você é capaz de fazer isso? O que aconteceria se hoje aquele banco de dados estivesse fora do ar e você tivesse que recriar do zero? Como você iria pegar os dados do backup? Quanto tempo demoraria para o backup ser importado novamente naquele banco de dados? Como você consegue fazer esse teste? Então, existem diversas técnicas e maneiras para que você consiga fazer esses testes. E muitas dessas maneiras são simples, é manual. Parte do princípio que esse serviço está fora do ar. Como você faz agora? “Mata” aquele banco de dados, faz com que aquela aplicação caia. O que acontece se esse cluster ficar fora do ar? Você consegue subir rapidamente em uma outra zona de disponibilidade? Ou seja, a recuperação pode ser de dados, pode ser de serviços, pode ser de aplicações que simplesmente caíram e precisam de autocura. 

Outro ponto importante, e um dos pontos mais comuns, é que você escale horizontalmente para aumentar a disponibilidade de carga de trabalho agregada. O que isso significa? Nós temos duas formas de escalar os serviços. E lembrando, o que é escalabilidade? Você consegue aumentar a quantidade de poder computacional para receber uma carga ou você consegue diminuir para receber também uma carga. Então, quando a gente está falando em escalabilidade horizontal, significa que ao invés de você sair aumentando a capacidade de uma única máquina,  você vai adicionando mais memória, mais CPU e etc. para ela ficar mais “parruda”. Assim, você consegue colocar diversas máquinas menores, uma ao lado da outra, recebendo e dividindo essa carga. Quanto mais você faz isso, você minimiza o risco do quê? De uma única máquina cair e você ficar 100% fora do ar. O que é muito diferente de você ter várias rodando e dividindo esse nível de risco com você. Fora que, quando você escala horizontalmente, você pode escalar de forma geral, vamos dizer assim, de forma infinita. Não existe infinidade, principalmente quando você está na cloud, mas você consegue escalar muito mais do que se você fosse escalar verticalmente. 

Pare de adivinhar a capacidade. Esse é um tema bem interessante porque, na maioria das vezes, você tem que partir do princípio: “quanto eu vou precisar de poder computacional para rodar esse workload?” E você vai cair naquela sensação que é a seguinte, “ah, não sei, eu vou botar uma máquina com 5V CPU e 30 gigas de memória. Mas de onde saiu esse número? Você tem um histórico anterior para conseguir corroborar? Se você tem, você não está adivinhando, você já está partindo do princípio de um dado que você já tinha. Porém, quando você não tem dado anterior, você não sabe como aquilo vai se portar, como você vai simplesmente chutar algum valor? Você não chuta, você faz teste de carga! Você sobe uma aplicação igualzinha, no ambiente controlado, manda um monte de request, vê como que essa aplicação se comporta, organiza tudo isso, e vê se é melhor aumentar a máquina verticalmente ou horizontalmente. Você consegue fazer esses ajustes finos e, depois disso, coloca no ar. Raramente você vai acertar tudo de uma vez. Por que eu digo isso? Porque acertar pode ser para mais ou para menos. Se você rodar botando muito poder computacional, sua empresa vai gastar dinheiro à toa, mas se você colocar de menos, a aplicação não vai “estar” confiável, que é o nosso assunto, que estamos trabalhando. Então, teste de carga para tudo que você for fazer. Você tem que ter dados para corroborar a sua decisão em relação à capacidade. E gerencie mudança de forma automatizada.

 Novamente, como eu consigo garantir que todas as alterações, tudo que eu preciso fazer, de forma geral aconteçam automaticamente? Por exemplo, escalar horizontalmente. Você tem que ter um ASG (Auto Scale Group), que faça isso automaticamente. Você tem que setar esses limites, você tem que diminuir. Então, essas coisas automatizadas não só vão facilitar no dia a dia a operação, como ao mesmo tempo vão fazer com que a sua aplicação rode de uma forma mais eficiente. A gente vai para a parte de eficiência já já. Então, é isso, em relação à parte de princípios de confiabilidade. Vamos para o nosso próximo princípio.