Bom pessoal, agora eu quero falar sobre CQRS (Command Responsibility Segregation). Olha que nome top! Mas para que serve essa parada? E aonde o CQRS vai nos ajudar? A ideia do CQRS é bem simples, porém, você não precisa utilizar CQRS em todos os aspectos. Você não precisa sair utilizando o CQRS em todos os cruds, para fazer crud. Você vai entender como que o CQRS consegue te ajudar. Vamos imaginar que eu tenho aqui a minha aplicação, ou seja, tem a camada de apresentação, a aplicação cai no domínio, regras de negócio, bateu na infraestrutura, CC, banco de dados, etc. O que acontece aqui nesse momento? Vamos pensar um pouco sobre o que acontece quando nós fazemos uma mudança no sistema. Vamos imaginar: Eu criei um novo usuário, e acontece muito assim. Eu mando uma request para um HTTP, fiz um post, na hora que eu recebi um post, eu criei o usuário e daí eu até retorno um JSON com os dados do usuário criado com o ID. Se você perceber, essa minha requisição está fazendo mais do que criar o usuário, ela está mudando o meu banco de dados e também fazendo uma consulta para retornar os dados desse cara que foi criado. Agora, e se a gente tivesse uma forma de separar o que é leitura e o que é gravação para facilitar a nossa vida em diversos momentos da nossa aplicação, conforme as coisas foram crescendo?

 

Olha só que interessante, vamos imaginar que eu tenho uma camada de apresentação aqui. Quando eu tenho essa minha camada de apresentação, eu crio um lado da minha aplicação chamado de Command Stack. O que é Command Stack? É uma camada, uma área da minha aplicação onde eu tenho apenas mudanças de estado na minha aplicação. Criei um usuário, alterei um email, fiz um update ou alguma coisa, ou seja, a minha intenção é de causar mutação, então, eu estou na minha command stack. A minha apresentação recebe essa informação, bate na minha aplicação, rodo regras de domínio, acesso o banco de dados e acabou. Nesse ponto, percebe que, quando eu crio alguma coisa, eu não vou retornar algo em troca. Assim, na hora que eu crio um comando, eu apenas executo o comando e acabou. Eu retorno o Void, eu não sei nem se deu certo esse comando. Se deu algo errado, o que eu vou fazer é retornar uma simples exception, ok? Caso contrário, eu vou rodar o comando e acabou. Logo, se eu criar um novo usuário eu rodo e pronto, criei o usuário. Agora, como a pessoa vai pegar esse usuário? Não tem nada a ver comigo, porque eu só gravo essa minha área do meu sistema, ela serve apenas para gravação. Uma coisa interessante que temos que pensar é que eu tenho uma outra área do meu sistema, que é a Query Stack, onde eu tenho apenas a minha aplicação. Se você perceber, eu não estou nem passando pelo modelo de domínio. Por quê? Porque se alguém quer os usuários, eu não quero saber. Se o usuário tem que chamar um repositório para carregar um modelo de domínio, para retornar o meu agregado inteiro, nada disso. O cara quer receber os usuários, eu bato na aplicação, seleciono os usuários, retorna esses usuário e não interessa mais nada, ou seja, eu posso pular regras de negócio e eu posso fazer muita coisa.

 

E por que isso pode me ajudar? Nós temos que pensar, galera, que no sistema de forma geral, se você tem 10.000 visualizações, é porque você teve, por exemplo, 1.000 escritas. Normalmente, a visualização é muito mais forte do que a escrita. Eu não estou dizendo que isso é regra, certo? Assim, para eu conseguir deixar o meu sistema eventualmente mais performático, mas também evitar com que o meu sistema tenha que ficar rodando regras de domínio ou qualquer coisa desse tipo, o que simplesmente eu posso fazer? Quando a pessoa quiser consultar, eu vou resolver o problema dela de consulta e acabou. Legal? Quando a pessoa quiser gravar, eu vou resolver a regra dela passando pelas minhas regras de negócio para fazer a gravação. Então, por exemplo, se eu for querer gerar um crediário, eu vou gerar, ele vai criar o número de parcelas, vai fazer todas as regras malucas e difíceis. Agora, se eu quiser saber só as parcelas, eu não preciso acessar o modelo de domínio, eu pego as parcelas onde usuário é tal e retorne para o cara, por exemplo. É uma facilidade muito maior.

 

Logo, quando eu consigo separar essas responsabilidades, eu tenho diversas vantagens. Uma, eu consigo retornar os dados da forma mais fácil para o usuário, eu consigo ter views materializadas para retornar tudo da forma mais fácil, consigo ter mais performance para trabalhar dessa forma inclusive e eu consigo deixar a parte com responsabilidade de modelo de domínio somente em uma parte da aplicação. E, para falar a verdade, não é tão difícil desenvolver uma aplicação utilizando CQRS. Mas, é óbvio, você tem que mudar um pouco esse paradigma, porque o seu comando só executa algo, ele não retorna algo para você. Legal? Agora, uma coisa interessante aqui é que quando você está separando essa parte de escrita e da parte de leitura, você também tem uma opção. E, essa opção é a seguinte: você pode criar um banco de dados de escrita e um banco de dados de leitura. Olha só que interessante. O meu banco de dados de escrita vai recebendo todas as gravações. O banco de dados de escrita sincroniza no banco de dados de leitura e a minha leitura acontece totalmente separada da minha escrita. Isso não é obrigatoriedade do CQRS, mas você pode fazer isso. Um outro ponto importante é que eu posso, por exemplo, fazer algumas coisas interessantes. Por exemplo, eu posso gravar em uma SQL e fazer a minha leitura em um Cassandra e eu posso gravar em um DynamoDB e retornar para fazer algumas leituras no Mongo.

 

Não faria muito sentido gravar no Mongo, ler no Dyno ou qualquer coisa desse tipo, mas, ou seja, você pode fazer com que o seu banco de dados seja utilizado e otimizado para as operações que façam sentido. Logo, eu vou pegar um banco de dados que é muito bom para gravação. Eu vou pegar um banco de dados que eu consigo manipular muito bem a parte de leitura. Então, com CQRS eu consigo fazer esse tipo de coisa. Portanto, é importante a gente entender que quem criou essa pegada de CQRS foi um camarada chamado de Gregory Yang, e tudo isso veio de uma ideia de um outro padrão que é chamado de CQS, que é (Command Query Separation), que é do Bertrand Meyer. A ideia desse cara é eu conseguir fazer alguns tipos de separação, como eu falei para você. Tudo o que é ação, não retorna nada. Mas, isso aí era algo muito mais de baixo nível, inclusive. O CQRS olha isso de uma forma muito mais de alto nível arquitetural do que necessariamente também dentro da aplicação. Então, é importante você saber que existe o CQS e o CQRS. Legal? Um grande abraço, tudo de bom e até o nosso próximo vídeo.